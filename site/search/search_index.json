{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Docker, Virtual Machines & Networks","text":"<p>Welcome! Use the sidebar to navigate to different sections of this project.</p>"},{"location":"#docker","title":"Docker","text":"<ul> <li>Docker Build</li> <li>Docker Networking</li> <li>Docker Macvlan Network</li> <li>Communication Between Inside &amp; Outside Docker</li> <li>Docker Container Interfaces</li> <li>Docker Engine on Ubuntu</li> <li>Using tarballs (.tgz)</li> <li>Docker Compose</li> <li>Docker Volumes</li> </ul>"},{"location":"#virtualization","title":"Virtualization","text":"<ul> <li>VM-to-VM Communication</li> <li>Fix Slow Ubuntu VM Boot</li> <li>Recovering VM</li> </ul>"},{"location":"#tools","title":"Tools","text":"<ul> <li>SSH Setup</li> <li>Matlab Setup</li> <li>Wine on Linux</li> <li>SQL</li> <li>[PostgreSQL] (PostgreSQL.md)</li> <li>Matlab Data Sources</li> </ul>"},{"location":"#scada","title":"SCADA","text":"<ul> <li>ScadaLTS</li> </ul>"},{"location":"#os","title":"OS","text":"<ul> <li>Mac Notes</li> </ul>"},{"location":"CommunicationBetweenInsideAndOutsideDocker/","title":"Communication Inside & Outside Docker","text":"<p>what does this mean and should I try connecting to this ip address if I have an sql database in a docker container on Macbook and I'm trying to connect to it from a python script inside an ubuntu vm in virtual box</p> <p>sreedevirajavelu@srees-MacBook-Air ~ % ipconfig getifaddr en0</p> <p>10.34.11.15 sreedevirajavelu@srees-MacBook-Air ~ % </p> <p>The IP address <code>10.34.11.15</code> is your MacBook\u2019s local network IP address on the <code>en0</code> interface (usually Wi-Fi).</p>"},{"location":"CommunicationBetweenInsideAndOutsideDocker/#what-this-means-for-your-setup","title":"What this means for your setup:","text":"<ul> <li>Your MacBook\u2019s Docker container MySQL is running on <code>localhost</code> inside your MacBook.</li> <li>Your Ubuntu VM in VirtualBox is a separate machine from the MacBook host.</li> <li>The VM needs to reach the Docker container through your MacBook\u2019s network IP (10.34.11.15) if networking between the VM and the Mac is set up properly.</li> </ul>"},{"location":"CommunicationBetweenInsideAndOutsideDocker/#can-you-connect-to-the-mysql-docker-container-on-ip-10341115-from-the-ubuntu-vm","title":"Can you connect to the MySQL Docker container on IP <code>10.34.11.15</code> from the Ubuntu VM?","text":"<p>It depends on the VirtualBox network mode:</p> <ol> <li> <p>NAT (default):</p> </li> <li> <p>The VM is behind a NAT and cannot directly access host IP like <code>10.34.11.15</code>.</p> </li> <li> <p>You would need to set up port forwarding in VirtualBox to forward the host port 3306 to the VM or use other tricks.</p> </li> <li> <p>Bridged Adapter:</p> </li> <li> <p>The VM gets an IP on the same LAN as your MacBook.</p> </li> <li> <p>VM can directly access <code>10.34.11.15</code> on port 3306 if firewall allows.</p> </li> <li> <p>Host-only Adapter:</p> </li> <li> <p>VM and host can communicate using a special virtual network IP (not the LAN IP).</p> </li> <li>You\u2019d check the IP of the host on that virtual network interface.</li> </ol>"},{"location":"CommunicationBetweenInsideAndOutsideDocker/#what-should-you-do","title":"What should you do?","text":"<ul> <li> <p>Check your VM\u2019s network mode in VirtualBox settings.</p> </li> <li> <p>If it\u2019s NAT, either:</p> </li> <li> <p>Switch to Bridged Adapter mode for the VM to be on the same LAN as the Mac, or</p> </li> <li> <p>Set up port forwarding in VirtualBox (host port 3306 \u2192 VM port 3306).</p> </li> <li> <p>Try to ping the MacBook\u2019s IP (<code>10.34.11.15</code>) from inside the Ubuntu VM:</p> </li> </ul> <pre><code>ping 10.34.11.15\n</code></pre> <p>If ping works and firewall allows, you can try to connect to MySQL at <code>10.34.11.15:3306</code> from your Python script running in the VM.</p>"},{"location":"CommunicationBetweenInsideAndOutsideDocker/#summary","title":"Summary","text":"Your Mac IP VM network type Access from VM to MySQL container? <code>10.34.11.15</code> NAT No direct access without port forwarding <code>10.34.11.15</code> Bridged Adapter Yes, direct access if firewall allows VirtualBox host-only IP Host-only Adapter Access via that network IP, not <code>10.34.11.15</code> <p>If you want, I can guide you how to set up VirtualBox network so the VM can access your Docker MySQL on the Mac!</p>"},{"location":"DockerBuild/","title":"Docker Build","text":""},{"location":"DockerBuild/#building-docker-images","title":"Building Docker images","text":"<p><code>docker build --network host --tag database .</code></p> <p>What each part does:</p> <ul> <li> <p><code>docker build</code>: command to build a Docker image</p> </li> <li> <p><code>--network host</code>: uses host's network stack during the build process (allows the build to access network resources as if it were running directly on the host machine)</p> </li> <li> <p><code>--tag database</code>: tags (names) the resulting image as \"database\"</p> </li> <li> <p><code>.</code>: uses current directory as the build context (where Docker looks for the Dockerfile and any files it needs to copy)</p> </li> <li> <p><code>--network host</code>: this flag is often used when the build process needs to download packages or access network resources that might be blocked by Docker's default networking.</p> </li> </ul>"},{"location":"DockerEngine_Ubuntu/","title":"Docker Engine on Ubuntu","text":"<p>Steps to install Docker Engine on ubuntu 24.04.2 :</p> <ul> <li>https://docs.docker.com/engine/install/ubuntu/</li> </ul> <p>Check ubuntu version using:</p> <ul> <li><code>lsb_release -a</code></li> <li><code>cat /etc/os-release</code></li> </ul> <p></p> <p>Check CPU architecture - <code>uname -m</code></p> <ul> <li>x86_64 \u2192 64-bit Intel/AMD (amd64) \u2705 supported</li> <li>aarch64 \u2192 64-bit ARM (arm64) \u2705 supported</li> <li>armv7l \u2192 32-bit ARM \u274c not supported by Docker Engine</li> <li>s390x, ppc64le \u2192 supported but only on special hardware</li> </ul> <p>On a VirtualBox VM on a MacBook, you\u2019ll almost certainly see x86_64 if your Mac is Intel-based, or aarch64 if your MacBook is Apple Silicon (M1/M2/M3).</p> <p></p> <p>Steps taken from https://docs.docker.com/engine/install/ubuntu/ </p> <p>Run the following command to uninstall all conflicting packages:</p> <pre><code>for pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done\n</code></pre> <p>Install using the apt repository</p> <p>Before you install Docker Engine for the first time on a new host machine, you need to set up the Docker apt repository. Afterward, you can install and update Docker from the repository.</p> <ol> <li>Set up Docker's apt repository.</li> </ol> <pre><code># Add Docker's official GPG key:\nsudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n\n# Add the repository to Apt sources:\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release &amp;&amp; echo \"${UBUNTU_CODENAME:-$VERSION_CODENAME}\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n</code></pre> <ol> <li>Install the Docker packages</li> </ol> <p>To install the latest version, run:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <p>Note: The Docker service starts automatically after installation. To verify that Docker is running, use:</p> <p><code>sudo systemctl status docker</code></p> <p>Some systems may have this behavior disabled and will require a manual start:</p> <p><code>sudo systemctl start docker</code></p>"},{"location":"DockerEngine_Ubuntu/#issues-and-fixes","title":"Issues and Fixes","text":"<p><code>docker --version</code> works but </p> <p>for <code>docker ps</code> gives permission denied error meaning current user ubuntu does not have permission to access the Docker socket </p> <p>Solution: </p> <ol> <li>Check the socket permissions </li> </ol> <p><code>ls -l /var/run/docker.sock</code></p> <p>If you see something like: <code>srw-rw---- 1 root docker 0 Oct 10 13:20 /var/run/docker.sock</code></p> <p>That means only users in the docker group can use it.</p> <ol> <li>Add your user to the docker group</li> </ol> <p><code>sudo usermod -aG docker $USER</code></p> <p>Then log out and log back in - the new group membership only takes effect after re-login</p>"},{"location":"Docker_Compose/","title":"Docker Compose","text":""},{"location":"Docker_Compose/#difference-between-docker-compose-up-with-hyphen-and-docker-compose-up-d-no-hyphen-between-docker-and-compose","title":"Difference between docker-compose up (with hyphen) and docker compose up -d (no hyphen between docker and compose )","text":""},{"location":"Docker_Compose/#docker-compose-up-with-hyphen","title":"docker-compose up (with hyphen)","text":"<ul> <li>uses old Docker Compose (v1) which is a python based tool</li> <li>starts containers in the foreground, so you will see all logs from all containers in your terminal</li> <li>if you stop the terminal (Ctrl C) , the containers are also stopped unless you add the -d (detached)</li> <li>this command is still supported, but considered legacy - Docker now recommends the plugin-based syntax  </li> </ul>"},{"location":"Docker_Compose/#docker-compose-up-d-no-hyphen-between-docker-compose","title":"docker compose up -d (no hyphen between docker &amp; compose)","text":"<ul> <li>uses new Docker Compose (v2), which is now part of the docker CLI as plugin</li> <li>-d means detached mode:</li> <li>containers start in the background. </li> <li>you get your terminal back immediately</li> <li>logs are not streamed to terminal but you can view it with <code>docker compose logs -f</code></li> </ul>"},{"location":"Docker_Container_Interfaces/","title":"Docker Container Interfaces","text":""},{"location":"Docker_Container_Interfaces/#docker-container-interfaces","title":"Docker Container Interfaces","text":"<ul> <li><code>ip a</code> inside the docker container of an IED after <code>docker exec -it ds1cb1 bash</code>:</li> </ul> <p>Different use cases of the 2 network interfaces:</p>"},{"location":"Docker_Container_Interfaces/#1-eth0-1001624","title":"1. <code>eth0 : 10.0.1.6/24</code>","text":"<p>Default interface created when the container is attached to a Docker network (bridge, overlay, or custom)</p> <p>Use case:</p> <ul> <li>Used for container-to-container communication inside the same Docker network</li> <li>Other containers on the same network (subnet <code>10.0.1.0/24</code>) can reach this container via <code>10.0.1.6</code></li> <li>Not directly routable from the host machine unless you expose ports (via <code>-p host_port:container_port</code>)</li> </ul> <p>Example:</p> <ul> <li>If you have another container on the same Docker network, it can <code>ping 10.0.1.6</code> or connect directly to its services.</li> </ul>"},{"location":"Docker_Container_Interfaces/#2-eth1-17224101124","title":"2. <code>eth1 : 172.24.10.11/24</code>","text":"<p>A second interface \u2014 likely because you attached this container to another Docker network (such as with <code>--network</code> flag or via Docker Compose multiple networks)</p> <p>Use case:</p> <ul> <li>Provides connectivity to containers/services on the <code>172.24.10.0/24</code> subnet</li> <li>Might be used for external integration (such as simulating a \"backend network\" while <code>eth0</code> handles a \"frontend network\")</li> <li>Useful in multi-network setups, where a container acts as a bridge between 2 networks</li> </ul> <p>Example:</p> <ul> <li>If you are running a database container on the <code>172.24.10.0/24</code> network, this container can talk to it via <code>172.24.10.x</code></li> </ul>"},{"location":"Docker_Container_Interfaces/#which-ip-can-you-use-from-the-host-machine","title":"Which IP can you use from the host machine?","text":"<ul> <li>Normally, you don't use these internal container IPs from the host.</li> <li>Instead:</li> <li>Use localhost (127.0.0.1) on the host with port mappings (-p 8080:80)</li> <li>If using macvlan/host networks, the container may be directly reachable on one of these IPs (<code>10.0.1.6</code> or <code>172.24.10.11</code>) from the host or even other machines on the LAN.</li> </ul>"},{"location":"Docker_Container_Interfaces/#summary","title":"Summary:","text":"<ul> <li><code>eth0 (10.0.1.6)</code> : main Docker network, container-to-container communication.</li> <li><code>eth1 (172.24.10.0)</code>: secondary Docker network, used if container needs to talk to another isolated group of services.</li> <li>From the host, you usually connect via <code>localhost</code>+ published ports, unless you intentionally configured a special network (macvlan, host, overlay).</li> </ul> <p>To check if these IPs are reachable directly from host or internal-only :</p> <p>...to be continued...</p>"},{"location":"Docker_Macvlan_Network/","title":"Docker Macvlan Network","text":""},{"location":"Docker_Macvlan_Network/#docker-macvlan-network","title":"Docker Macvlan Network","text":"<p>A macvlan nerwork allows each Docker container to appear on the same Layer 2 network as your host (Ubuntu VM).</p> <ul> <li> <p>Each container gets its own unique IP address on your physical LAN (e.g. 192.168.30.x)</p> </li> <li> <p>The containers can be reached directly by other devices on that LAN - without NAT.</p> </li> </ul> <p>Because of that, the macvlan network must be bound to your host's physical network interface (the one actually connected to your LAN or VM bridge).</p>"},{"location":"Docker_Macvlan_Network/#2-choosing-the-correct-interface-to-create-mavvlan-network","title":"\ud83e\udde9 2\ufe0f\u20e3 Choosing the correct interface to create Mavvlan network","text":"<p>ip a output</p> <pre><code>ubuntu@pgt:~$ ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host \n       valid_lft forever preferred_lft forever\n2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether 08:00:27:62:7e:2a brd ff:ff:ff:ff:ff:ff\n    inet 192.168.30.60/24 brd 192.168.30.255 scope global enp0s3\n       valid_lft forever preferred_lft forever\n    inet6 fe80::a00:27ff:fe62:7e2a/64 scope link \n       valid_lft forever preferred_lft forever\n3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default \n    link/ether 52:18:4f:1d:0b:aa brd ff:ff:ff:ff:ff:ff\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::5018:4fff:fe1d:baa/64 scope link \n       valid_lft forever preferred_lft forever\nubuntu@pgt:~$ \n</code></pre> <p>From your ip a output:</p> <p>2: enp0s3:  <pre><code>inet 192.168.30.60/24\n</code></pre> <p>\u2705 enp0s3 is UP, has a valid IPv4 (192.168.30.60/24), and is your main interface connected to the external network.</p> <p>That makes enp0s3 the correct interface to use for a macvlan network.</p> <p>The others:</p> <p>lo \u2014 loopback (ignore)</p> <p>docker0 \u2014 Docker\u2019s internal bridge (not physical, so not usable for macvlan)</p> <p>So yes, you should use enp0s3 for your macvlan setup.</p> <p></p> <p>There are three private IPv4 address ranges defined by RFC 1918. These are reserved for internal networks only (they are not routable on the public Internet).</p> Private Range CIDR Typical Use <code>10.0.0.0</code> \u2013 <code>10.255.255.255</code> <code>/8</code> Large enterprise LANs <code>172.16.0.0</code> \u2013 <code>172.31.255.255</code> <code>/12</code> Corporate or internal subnets <code>192.168.0.0</code> \u2013 <code>192.168.255.255</code> <code>/16</code> Home, office, and VM networks <p>ubuntu@pgt:~$ ip route</p> <p>default via 192.168.30.1 dev enp0s3 proto static </p> <p>172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown </p> <p>192.168.30.0/24 dev enp0s3 proto kernel scope link src 192.168.30.60 </p> <p>ubuntu@pgt:~$ </p>"},{"location":"Docker_Networks/","title":"Docker Networking","text":""},{"location":"Docker_Networks/#docker-networking-tutorial-bridge-none-host-ipvlan-macvlan-overlay","title":"Docker Networking Tutorial (Bridge - None - Host - IPvlan - Macvlan - Overlay)","text":"<p>Reference: https://youtu.be/fBRgw5dyBd4?si=LodjJDx4AdnjYOS6</p>"},{"location":"Docker_Networks/#docker-bridge","title":"Docker Bridge","text":"<ul> <li>2 segments that the bridge connects is:</li> <li>local host e.g. your laptop, or linux server where you run your Docker containers</li> <li>virtual network created by Docker</li> <li></li> </ul>"},{"location":"Docker_Networks/#when-you-install-docker-for-the-first-time-it-will-create-a-default-bridge-network-on-the-host-slightly-different-on-macos-as-it-will-run-al-containers-inside-a-linux-vm-virtualization-framework","title":"When you install Docker for the first time, it will create a default bridge network on the host (slightly different on MacOS as it will run al containers inside a Linux VM, virtualization framework)","text":"<ul> <li>all containers you create on that host will get an IP address on that range</li> </ul> <p>On a Linux host, Docker Engine directly creates a docker0 bridge network interface in the host\u2019s network stack. That\u2019s the familiar default bridge you see with ifconfig or ip a (usually 172.17.0.1/16). </p> <p>On a Mac (macOS) or Windows, things are different:</p> <p>Docker Desktop does not create a native docker0 bridge interface on your MacBook\u2019s network stack.</p> <p>Instead, Docker Desktop runs all containers inside a lightweight Linux VM (on macOS, this is managed using Apple\u2019s HyperKit or now a Virtualization Framework).</p> <p>Inside that VM, Docker does create a docker0 bridge (just like on Linux). But this bridge is inside the VM, not on macOS itself.</p> <p>From your MacBook\u2019s perspective, you won\u2019t see docker0 if you run ifconfig or ip a. Instead, Docker Desktop sets up a special networking layer that forwards traffic between your MacBook and the VM.</p> <p>So to answer directly:</p> <p>\ud83d\udc49 No, Docker Desktop does not create a default bridge network on your MacBook\u2019s host network stack. \ud83d\udc49 Yes, it does create a default bridge network inside the Linux VM where your containers run.</p> <p>If you run: <code>docker network ls</code> you\u2019ll still see bridge, host, and none listed, because those networks exist in the Docker VM environment, even though your Mac itself doesn\u2019t expose them as interfaces.</p> <p>Do you want me to also explain how you can check the actual IP range of the bridge network inside Docker Desktop on your Mac?</p>"},{"location":"Docker_Networks/#containers-created-in-the-default-bridge-network","title":"Containers created in the default bridge network","text":"<ul> <li>can communicate with each other</li> <li>default bridge network has restrictions and is not recommended for production, better to use user-defined bridge network.</li> <li>Default bridge network: Cannot use container DNS from host </li> <li>In default bridge network, DNS is not supported. Also cannot use DNS to send requests between containers.</li> </ul>"},{"location":"Docker_Networks/#user-defined-bridge-network","title":"User defined bridge network**:","text":"<ul> <li>Can use DNS to send requests to containers. </li> <li>This only applies to communications inside the bridge network between containers. You still will NOT be able to use the container DNS from the host.</li> </ul>"},{"location":"Docker_Networks/#host-mode-networking-option","title":"Host mode - networking option","text":"<ul> <li>container will not get its own IP and instead share the same networking namespace as the host where you run the container</li> <li>will appear as if you were running a regular application on that host</li> <li>thus any application running on a different server will be able to access the container using the host's IP address</li> </ul>"},{"location":"Docker_Networks/#ipvlan-network","title":"IPvlan network:","text":"<ul> <li>Traditionally, to expose a container to the outside world we used bridge network. But it adds additional complexity and performance penalty. Packet needs to go through additional hop, need to map ports from the container to the host to expose it to other applications.  </li> <li>Does not use a bridge for isolation and is associated directly with the Linux network interface. No need for port mappings in these scenarios.</li> </ul>"},{"location":"Docker_Networks/#macvlan-network","title":"MacVLAN network:","text":"<ul> <li>Some legacy applications and those that monitor network traffic expect to be directly connected to the physical network.</li> <li>In this case, can use the MacVLAN network driver to assign a MAC address to each container's virtual network interface.</li> <li>It will appear as a physical network interface directly connected to the physical network.</li> <li>to create it, must specify the subnet that the host uses, the gateway, and the parent network interface</li> <li>compare the parent MAC address (parent interface) -&gt; e.g. ip addr show ens33</li> <li>MAC address of the container -&gt; ssh into it and do <code>ip addr</code></li> </ul>"},{"location":"Docker_Networks/#difference-between-ipvlan-and-macvlan","title":"Difference between IPVLAN and MACVLAN:","text":"<ul> <li>if use IPVLAN: container will get the same MAC address as your host</li> <li>if use MACVLAN: container will have a different MAC address from host</li> </ul>"},{"location":"Docker_Networks/#overlay-network","title":"Overlay network","text":"<ul> <li>When you deploy your applications to production, you will need more than one physical or virtual server, each with a Docker daemon installed.</li> <li>The overlay network driver creates a distributed network among multiple Docker daemon hosts.</li> <li>This network sits on top of (overlays) the host-specific networks, allowing containers connected to it to communicate securely, especially when encryption is enabled.</li> <li>Most frequently, this type of network is used with Docker Swarm , but it is also possible to connect individual containers.</li> <li>Comment from youtuber: to manage containers at scale, especially in production, consider using Kubernetes.</li> <li>need to disable</li> <li>Example of usage of overlay network:</li> <li><code>2 ubuntu VMs</code></li> <li>find network interfaces on both VMs, e.g. ens33 on both VMs -&gt; disable this on the network interface on both VMs</li> <li><code>sudo ethtool -K ens33 tx-checksum-ip-generic off</code> (not persistent across restarts so might need to use something like a script using systemd service to automatically run it on boot)</li> <li>Even if you want to connect individual containers to overlay network, we still need to initialize the Docker Swarm</li> <li>on the first VM, run <code>docker swarm init</code></li> <li>will give a command you can execute on other VMs to join the Docker Swarm</li> <li>each VM must have docker installed</li> <li>manager and worker nodes (the VMs)</li> <li>on manager, create an overlay network and an attachable flag for individual containers to be able to use this network. Otherwise only swarm services will be able to use it.</li> <li>on the worker node (VM) if you do <code>docker network ls</code>, you will only see the overlay network when you start a container that uses the network (can start on the manager node)</li> <li>to verify that we can access containers on that overlay network deployed on different VMs, can SSH to the second container and use curl to send a request to the first container on the manager node</li> <li></li> </ul>"},{"location":"Docker_Networks/#overlay-networks","title":"Overlay Networks","text":"<ul> <li>Allow containers running on different Docker hosts (machines) to communicate with each other as if they are on the same local network, while keeping the communcation secure and isolated.</li> </ul> <p>Why normal Docker networks is not enough? - By default, Docker creates a bridge network on a single host (like bridge0 on Linux) - Containers connected to this bridge can talk to each other, but only on the same host.</p> <p>If you want:  - multiple physical/virtual servers - running containers that need to talk to each other - Need something that span across hosts</p>"},{"location":"Docker_Networks/#how-overlay-networks-work","title":"How overlay networks work?","text":"<ul> <li>Docker creates a virtual distributed network that spans all participating nodes (hosts).</li> <li>uses VXLAN tunneling (encapsulating packets inside UDP) so that container-to-container traffic can move across hosts transparently.</li> <li>network is managed by Docker swarm or Docker engine in swarm mode</li> </ul> <p>Example: - Host A has a container running web. - Host B has a container running db. - Both containers join the same overlay network called backend-net. - Now web can talk to db using the container name (db:3306), even though they are on different machines.</p>"},{"location":"Docker_Volumes/","title":"Docker Volumes","text":""},{"location":"Docker_Volumes/#what-is-a-volume-in-docker","title":"What is a Volume in Docker","text":"<p>Think of Docker container as a small isolated computer - when you stop or delete it, everything inside disappears (its 'disk' is temporary).</p> <p>A Docker volume is like pluggin in an external hard drive or shared folder to that container.</p> <p>It lets you:</p> <ol> <li>Keep data even after container is stopped or removed.</li> <li>Share files between real machine (the host) and the container.</li> </ol> <p>There are 2 main types of volume mounts:</p> <ul> <li>Bind mount (links a folder from your host machine to the container)</li> <li>Named volume (managed entirely by Docker - stored somewhere under <code>/var/lib/docker/volumes</code>)</li> </ul> <p>Explanation for use of volumes:</p> <ul> <li>Left side (<code>./sql</code>) -&gt; a folder on your computer at the same level as your docker-compose.yml file</li> <li>Right side (<code>/docker-entrypoint-initdb.d</code>) -&gt; a special folder inside the container that MySQL checks when it first starts.</li> </ul> <p>When MySQL starts for the first time, it looks in <code>/docker-entrypoint-initdb.d</code> and automatically runs any <code>.sql</code> files it finds there - this is how it initializes your database.</p> <p>When Docker starts the MySQL container, it copies that folder into the container.</p> <p>MySQL executes your CCP_data.sql automatically - creating the tables, inserting initial data, etc.</p> <p>This mount does not store your database data (the rows &amp; tables you later insert). It only gives MySQL initialization scripts.</p> <p>Once MySQL is running, the database data is stored inside the container's temporary filesystem. If you delete the container, the data is lost.</p> <p>This is called a bind mount (it directly links your folder <code>./sql</code> from the host to the continer).</p> <p>Question:  does the special folder docker-entrypoint-initdb.d exist in every docker container ? if not where does it come from ?</p> <p>No, the folder /docker-entrypoint-initdb.d does not exist in every Docker container. It exists only in certain official database images (like MySQL, PostgreSQL, MongoDB, etc.) because the image creator chose to include it in the image\u2019s startup logic. </p> <p>Each image defines its own conventions about where to put configuration or initialization files.</p> <p>So when you use:</p> <pre><code>    volumes:\n      - ./sql:/docker-entrypoint-initdb.d\n</code></pre> <p>you are not telling Docker anything special - you are telling the MySQL container: When you run your startup script, here is the folder where you can find initialization files.</p>"},{"location":"Docker_Volumes/#content-of-docker-composeyml-file-to-use-postgresql-database-as-docker-container","title":"Content of docker-compose.yml file to use postgresql database as docker container","text":"<p>This version does not persist volume and data will vanish if you remove the container.</p> <pre><code>services:\n  postgres:\n    image: postgres:16\n    container_name: ccp-multi-ied-multi-plc\n    environment:\n      POSTGRES_USER: root\n      POSTGRES_PASSWORD: root\n      POSTGRES_DB: powerplant\n    ports:\n      - \"5432:5432\"\n    volumes:\n    - ./postgres-sql:/docker-entrypoint-initdb.d\n\n</code></pre> <p>Use of  - volumes: - ./sql:/docker-entrypoint-initdb.d</p> <ul> <li> <p>This mounts your host directory ./sql into the container\u2019s /docker-entrypoint-initdb.d directory.</p> </li> <li> <p>docker-entrypoint-initdb.d is a special folder: on first startup of the container, MySQL runs all .sql or .sh scripts there to initialize the DB.</p> </li> <li> <p>After initialization, new runs don\u2019t automatically re-run scripts unless you remove the container and volume.</p> </li> </ul> <p>\u2757 This is not where live database data is stored. Live data is in /var/lib/mysql. Since you\u2019re not mounting that, the data lives in a Docker-managed anonymous volume.</p> <p>So: Changing this bind mount will not remove your MySQL data. It only affects which init scripts would run on container creation.</p>"},{"location":"Docker_Volumes/#content-of-docker-composeyml-file-to-use-postgresql-database-as-docker-container-with-persistent-volume","title":"Content of docker-compose.yml file to use postgresql database as docker container (with persistent volume)","text":"<pre><code>services:\n  postgres:\n    image: postgres:16\n    container_name: ccp-multi-ied-multi-plc-pg\n    environment:\n      POSTGRES_USER: root\n      POSTGRES_PASSWORD: root\n      POSTGRES_DB: powerplant\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data   # &lt;-- persistent volume for DB data\n      - ./postgres-sql:/docker-entrypoint-initdb.d  # &lt;-- init scripts\n\nvolumes:\n  postgres_data:   # &lt;-- named volume definition\n</code></pre>"},{"location":"Docker_Volumes/#use-of-volumes-inside-postgresql-docker-composeyml","title":"Use of Volumes inside PostgreSQL docker-compose.yml","text":"<pre><code>volumes:\n- postgres_data:/var/lib/postgresql/data # persistent volume for DB data\n- ./postgres-sql:/docker-entrypoint-initdb.d # init scripts\n\nvolumes:\n  postgres_data: # named volume definition \n</code></pre> <p>Explanation of each line:</p> <ol> <li> <p><code>-postgres_data:/var/lib/postgresql/data</code></p> </li> <li> <p>left side (postgres_data) -&gt; a named volume, managed by Docker</p> </li> <li> <p>you don't see it as a folder on your host - Docker stores it internally (under /var/lib/docker/volumes/...)</p> </li> <li> <p>right side (/var/lib/postgresql/data) -&gt; the main folder inside the container where the PostgreSQL stores all its databases.</p> </li> </ol> <p>This means your PostgreSQL data (tables, records, etc.) is stored in the <code>postgres_data</code> volume not inside the temporary cotainer filesystem.</p> <p>Even if you:</p> <ul> <li> <p>stop the container (docker compose down)</p> </li> <li> <p>rebuild it</p> </li> <li> <p>restart it</p> </li> </ul> <p>the data remains intact, because the volume is persistent.</p> <p>If you ever want to delete the data, you explicitly run: <code>docker compose down -v</code></p> <ol> <li> <p><code>- postgres-sql:/docker-entrypoint-initdb.d</code></p> </li> <li> <p>it mounts your host folder <code>postgres-sql/</code> (next to your <code>docker-compose.yml</code>) into the container's <code>/docker-entrypoint-initdb.d</code> folder</p> </li> <li> <p>PostgreSQL automatically runs any <code>.sql</code> files there the first time the database is initialized (before any data exists).</p> </li> </ol> <p>So if you have <code>postgres-sql/CCP_data.sql</code>, it will create your tables and insert the initial values when the container is started for the first time.</p> <ol> <li>section at the bottom:</li> </ol> <pre><code>volumes:\n  postgres_data:\n</code></pre> <p>This declares the named volume used above, so Docker knows it should create and manage it.</p>"},{"location":"Docker_tgz/","title":"Using tarballs (.tgz)","text":""},{"location":"Docker_tgz/#what-is-a-docker-tgz-file","title":"What is a Docker .tgz file ?","text":"<p>In the Docker context, a <code>.tgz</code> file is a compressed archive of a Docker image created with:</p> <pre><code>  docker save -o image.tar &lt;image:tag&gt;\n\n  # then gzip it\n\n  tar czf image.tgz image.tar\n</code></pre> <p>Or directly:</p> <p><code>docker save &lt;image:tag&gt; | gzip &gt; image.tgz</code></p> <p>Inside the <code>.tgz</code>: - it is basically a tarball of JSON metadata and filesystem layer tarballs</p>"},{"location":"Docker_tgz/#to-make-modifications-to-docker-tgz-file","title":"To make modifications to Docker .tgz file","text":"<ul> <li>load the <code>.tgz</code> file into Docker (<code>docker load</code>)</li> <li>run a container from it</li> <li>make changes</li> <li><code>docker commit</code></li> <li><code>docker save</code></li> </ul>"},{"location":"Docker_tgz/#do-changes-to-tgz-persist","title":"Do changes to .tgz persist?","text":"<ul> <li>if you only change inside the running container from image, these changes don't go back into the .tgz. They live in the container's writable layer.</li> <li>To persist changes into a new <code>.tgz</code>:</li> <li>Run a container from the image</li> <li>Make modifications</li> <li>Commit the container -&gt; new image   <code>docker commit &lt;container-id&gt; myimage:modified</code></li> <li>Save it back:   <code>docker save myimage:modified | gzip &gt; myimage-modified.tgz</code></li> </ul> <p>## How .tgz files work in practice  - <code>.tgz</code> = portable snapshot of a Docker image  - you can transfer it, then use docker load &lt; my image.tgz to load it into Docker on another host  -  mostly for air-gapped environments (no Docker Hub access) or backups.</p>"},{"location":"Docker_tgz/#to-load-the-tgz-into-docker","title":"To load the .tgz into Docker","text":"<p><code>docker load &lt; myimage.tgz</code></p> <ul> <li>makes the image available locally so you can run containers from it</li> </ul>"},{"location":"Docker_tgz/#to-create-a-tgz-from-an-existing-image","title":"To create a .tgz from an existing image","text":"<p><code>docker save myimage:tag | gzip &gt; myimage.tgz</code> - now you can copy over myimage.tgz to another machine and docker load it there</p> <p>sreedevirajavelu@srees-MacBook-Air pgtwin_7ss % docker load -i 7ss_db_docker_20250218.tgz  unrecognized image format</p> <p>That error means the file 7ss_db_docker_20250218.tgz is not in the expected Docker save/load format. Let\u2019s debug step by step:</p> <ol> <li>What docker load expects <code>docker load -i file.tgz</code> only works if the archive was created using:</li> </ol> <p><code>docker save -o image_name.tgz image:tag</code></p> <p>This produces a tarball with manifest.json, repositories, and layer directories inside.</p> <p>If your .tgz was created another way (e.g., tar czf on a Docker context or folder), docker load will reject it.</p> <ol> <li>Check the contents of your .tgz</li> </ol> <p>Run on your MacBook: tar -tzf 7ss_db_docker_20250218.tgz | head -20 If you see manifest.json and layer directories \u2192 \u2705 this is a docker save image, and something else is wrong. If you see Dockerfile, requirements.txt, Panda-db/, etc. \u2192 \u274c this is just the build context, not an image.</p> <ol> <li>If it\u2019s a Docker context (not an image)</li> </ol> <p>You cannot load it directly. Instead you need to build: tar -xzf 7ss_db_docker_20250218.tgz -C ./extracted/ cd extracted docker build -t my-image:latest .</p> <ol> <li>If it is a valid docker save image</li> </ol> <p>Try re-loading: gunzip -c 7ss_db_docker_20250218.tgz | docker load (some tools produce gzip-compressed vs tar-compressed files differently).</p> <p>sreedevirajavelu@srees-MacBook-Air pgtwin_7ss % tar -tzf 7ss_db_docker_20250218.tgz | head -20</p> <p>7ss_db/</p> <p>7ss_db/docker-sql/</p> <p>7ss_db/docker-sql/pgtv4_pp_7ss_db_20240302.sql</p> <p>7ss_db/docker-sql/my.cnf</p> <p>7ss_db/docker-sql/build_fixed_max_conn.sh</p> <p>7ss_db/docker-sql/build.sh</p> <p>7ss_db/docker-sql/pandapower_db_initial.sql</p> <p>7ss_db/docker-sql/prepare_max_connections.py</p> <p>7ss_db/docker-sql/README.md</p> <p>7ss_db/docker-sql/pandapower_db_structure.sql</p> <p>7ss_db/docker-sql/Dockerfile</p> <p>7ss_db/docker-sql/run_db.sh</p> <p>sreedevirajavelu@srees-MacBook-Air pgtwin_7ss % </p>"},{"location":"Fix_Slow_UbuntuVM_Boot/","title":"Fix slow booting for ubuntu vm based on output of these commands to find what was slowing down the booting time","text":"<pre><code> systemd-analyze\n systemd-analyze blame\n</code></pre> <p>Top delay:</p> <p>2min 258ms systemd-networkd-wait-online.service</p> <p>This service alone adds over 2 minutes to your boot. That\u2019s practically your entire userspace delay.</p> <p>\ud83d\udd0d What is systemd-networkd-wait-online.service?</p> <p>It waits for the network to be fully up (like getting a DHCP lease or full connection). Used mostly on servers to ensure critical services only start after network is available. In most VMs and desktops, it's not necessary and can be safely disabled.</p> <p>\u2705 Fix: Disable the Wait-Online Service</p> <p>Run: - sudo systemctl disable systemd-networkd-wait-online.service - sudo systemctl mask systemd-networkd-wait-online.service</p> <p>\ud83d\udca1 mask ensures it cannot be accidentally started again.</p> <p>If you also see or use NetworkManager, you can disable its wait service too:</p> <p>sudo systemctl disable NetworkManager-wait-online.service</p> <p>sudo systemctl mask NetworkManager-wait-online.service</p> <p>\ud83d\udd01 Then reboot your VM: sudo reboot \ud83e\uddea After reboot:</p> <p>Check again: systemd-analyze You should see your boot time drop from 2+ minutes \u2192 ~15 seconds or less.</p> <p>\ud83d\udd01 To Undo the Effects of Disabling and Masking the Wait-Online Service If you previously ran:</p> <ul> <li> <p>sudo systemctl disable systemd-networkd-wait-online.service</p> </li> <li> <p>sudo systemctl mask systemd-networkd-wait-online.service</p> </li> </ul> <p>You can restore the service like this:</p> <p>\u2705 Step 1: Unmask the service</p> <ul> <li>sudo systemctl unmask systemd-networkd-wait-online.service</li> </ul> <p>\u2705 Step 2: Re-enable the service at boot</p> <ul> <li>sudo systemctl enable systemd-networkd-wait-online.service \u2705 Step 3 (Optional): Start it immediately (not needed for reboot use)</li> </ul> <p>sudo systemctl start systemd-networkd-wait-online.service</p> <p>\ud83d\udd01 Same steps apply if you disabled NetworkManager-wait-online.service: Just replace the service name in each command. Example:</p> <p>sudo systemctl unmask NetworkManager-wait-online.service</p> <p>sudo systemctl enable NetworkManager-wait-online.service</p> <p>\ud83e\uddea Confirm it's active again:</p> <p>systemctl status systemd-networkd-wait-online.service or systemctl is-enabled systemd-networkd-wait-online.service</p> <p>You should see:</p> <p><code>enabled</code></p> <p>\u2705 Summary: Rollback Commands</p>"},{"location":"Fix_Slow_UbuntuVM_Boot/#unmask-and-re-enable-systemd-networkd-wait-online","title":"Unmask and re-enable systemd-networkd-wait-online","text":"<p>sudo systemctl unmask systemd-networkd-wait-online.service</p> <p>sudo systemctl enable systemd-networkd-wait-online.service</p>"},{"location":"Fix_Slow_UbuntuVM_Boot/#optional-also-for-networkmanager-wait-online-if-previously-masked","title":"Optional: Also for NetworkManager-wait-online (if previously masked)","text":"<p>sudo systemctl unmask NetworkManager-wait-online.service</p> <p>sudo systemctl enable NetworkManager-wait-online.service</p>"},{"location":"Mac/","title":"Mac Notes","text":""},{"location":"Mac/#setting-up-ubuntu-vm-on-virtualbox-on-macbook-m4","title":"Setting up Ubuntu VM on VirtualBox on MacBook M4 :","text":"<p>https://www.youtube.com/watch?v=LjL_N0OZxvY</p>"},{"location":"Mac/#make-ubuntu-full-screen-in-virtualbox","title":"Make Ubuntu full screen in VirtualBox:","text":"<p>https://youtu.be/Fw8ppXeJ_GY?si=qu0ehtCFotNpaLcB - this tutorial also shows how to install guest additions</p>"},{"location":"Mac/#how-to-create-shared-folder-between-host-and-ubuntu-vm-on-virtualbox","title":"How to create shared folder between host and Ubuntu VM on VirtualBox:","text":"<p>https://youtu.be/j8Ne96h8UDg?si=aBwXLuINWmvPNp1l</p> <p>Fix slow booting for ubuntu vm based on output of these commands to find what was slowing down the booting time</p> <pre><code> systemd-analyze\n systemd-analyze blame\n</code></pre> <p></p> <p>Top delay:</p> <p>2min 258ms systemd-networkd-wait-online.service</p> <p>This service alone adds over 2 minutes to your boot. That\u2019s practically your entire userspace delay.</p> <p>\ud83d\udd0d What is systemd-networkd-wait-online.service?</p> <p>It waits for the network to be fully up (like getting a DHCP lease or full connection). Used mostly on servers to ensure critical services only start after network is available. In most VMs and desktops, it's not necessary and can be safely disabled.</p> <p>\u2705 Fix: Disable the Wait-Online Service</p> <p>Run: - sudo systemctl disable systemd-networkd-wait-online.service - sudo systemctl mask systemd-networkd-wait-online.service</p> <p>\ud83d\udca1 mask ensures it cannot be accidentally started again.</p> <p>If you also see or use NetworkManager, you can disable its wait service too:</p> <p>sudo systemctl disable NetworkManager-wait-online.service</p> <p>sudo systemctl mask NetworkManager-wait-online.service</p> <p>\ud83d\udd01 Then reboot your VM: sudo reboot \ud83e\uddea After reboot:</p> <p>Check again: systemd-analyze You should see your boot time drop from 2+ minutes \u2192 ~15 seconds or less.</p> <p>\ud83d\udd01 To Undo the Effects of Disabling and Masking the Wait-Online Service If you previously ran:</p> <ul> <li> <p>sudo systemctl disable systemd-networkd-wait-online.service</p> </li> <li> <p>sudo systemctl mask systemd-networkd-wait-online.service</p> </li> </ul> <p>You can restore the service like this:</p> <p>\u2705 Step 1: Unmask the service</p> <ul> <li>sudo systemctl unmask systemd-networkd-wait-online.service</li> </ul> <p>\u2705 Step 2: Re-enable the service at boot</p> <ul> <li>sudo systemctl enable systemd-networkd-wait-online.service \u2705 Step 3 (Optional): Start it immediately (not needed for reboot use)</li> </ul> <p>sudo systemctl start systemd-networkd-wait-online.service</p> <p>\ud83d\udd01 Same steps apply if you disabled NetworkManager-wait-online.service: Just replace the service name in each command. Example:</p> <p>sudo systemctl unmask NetworkManager-wait-online.service</p> <p>sudo systemctl enable NetworkManager-wait-online.service</p> <p>\ud83e\uddea Confirm it's active again:</p> <p>systemctl status systemd-networkd-wait-online.service or systemctl is-enabled systemd-networkd-wait-online.service</p> <p>You should see:</p> <p><code>enabled</code></p> <p>\u2705 Summary: Rollback Commands</p>"},{"location":"Mac/#unmask-and-re-enable-systemd-networkd-wait-online","title":"Unmask and re-enable systemd-networkd-wait-online","text":"<p>sudo systemctl unmask systemd-networkd-wait-online.service</p> <p>sudo systemctl enable systemd-networkd-wait-online.service</p>"},{"location":"Mac/#optional-also-for-networkmanager-wait-online-if-previously-masked","title":"Optional: Also for NetworkManager-wait-online (if previously masked)","text":"<p>sudo systemctl unmask NetworkManager-wait-online.service</p> <p>sudo systemctl enable NetworkManager-wait-online.service</p>"},{"location":"Matlab/","title":"Matlab","text":"<p>Install this Java Runtime before installing Matlab</p> <p>Java Runtime Required</p> <p>Native Apple silicon MATLAB requires a Java runtime be installed on your Mac. A supported Java 11 JRE is available free of charge with Amazon Corretto 11</p> <p>https://ww2.mathworks.cn/en/support/requirements/apple-silicon.html</p> <p>Had to install Xcode from App store</p>"},{"location":"Matlab_Data_Sources/","title":"Matlab Data Sources","text":""},{"location":"Matlab_Data_Sources/#matlab-data-sources-sql-vs-postgresql","title":"Matlab Data Sources - SQL vs PostgreSQL","text":""},{"location":"Matlab_Data_Sources/#postgresql-jdbc-for-macos","title":"PostgreSQL JDBC for macOS:","text":"<p>https://ww2.mathworks.cn/help/database/ug/postgresql-jdbc-for-macos.html</p>"},{"location":"Matlab_Data_Sources/#postgresql-jdbc-for-windows","title":"PostgreSQL JDBC for Windows:","text":"<p>https://ww2.mathworks.cn/help/database/ug/postgresql-jdbc-windows.html</p> <p>I have configured a JDBC data source on matlab using mysql-connector-j-9.3.0 as the driver , and connecting to a dockerized version of a mysql database, how can I change this to postgresql database instead with minimal changes?</p> <ol> <li>Replace JDBC Driver MySQL and PostgreSQL require different JDBC drivers: Current (MySQL): mysql-connector-j-9.3.0.jar Required (Postgres): postgresql-.jar (latest is 42.x) \ud83d\udc49 Download the .jar and place it in the same folder where MATLAB can access JDBC drivers (often under matlabroot/toolbox/local or a custom path you\u2019ve set). <p>Link to download JDBC Drivers</p> <p>https://ww2.mathworks.cn/en/products/database/driver-installation.html</p> <ul> <li>choose PostgreSQL JDBC driver</li> </ul> <p>\u2705 Which JDBC Driver to Use F rom the PostgreSQL JDBC site:</p> <p>You are on Postgres 16 \u2192 supported by all recent drivers.</p> <p>You are likely running Java 8+ (MATLAB since R2020a bundles Java 8, and newer releases may bundle Java 11).</p> <p>\ud83d\udc49 So you should use the JDBC 4.2 driver (version 42.7.8, latest stable). That means: <code>postgresql-42.7.8.jar</code> is the right driver for you.</p> <ul> <li> <p>check version of Java on Matlab</p> </li> <li> <p>check version of PostgreSQL used as JDBC data source</p> </li> </ul> <p>\ud83d\udd0d Things to Check Before Connecting</p> <p>Java Version in MATLAB</p> <p>In MATLAB, check which JVM it\u2019s using:</p> <p>version -java</p> <p>If it shows <code>Java 8 or higher</code>, you\u2019re good with <code>postgresql-42.7.8.jar</code>. If it shows Java 7 \u2192 use postgresql-42.2.29.jar. If Java 6 (unlikely unless MATLAB is very old) \u2192 use postgresql-42.2.27.jar.</p>"},{"location":"Matlab_Data_Sources/#content-of-docker-composeyml-file-to-use-postgresql-database-as-docker-container","title":"Content of docker-compose.yml file to use postgresql database as docker container","text":"<p>This version does not persist volume and data will vanish if you remove the container.</p> <pre><code>services:\n  postgres:\n    image: postgres:16\n    container_name: ccp-multi-ied-multi-plc\n    environment:\n      POSTGRES_USER: root\n      POSTGRES_PASSWORD: root\n      POSTGRES_DB: powerplant\n    ports:\n      - \"5432:5432\"\n    volumes:\n    - ./postgres-sql:/docker-entrypoint-initdb.d\n\n</code></pre> <p>Use of  -  volumes:       - ./sql:/docker-entrypoint-initdb.d</p> <pre><code>- This mounts your host directory ./sql into the container\u2019s /docker-entrypoint-initdb.d directory.\n\n- docker-entrypoint-initdb.d is a special folder: on first startup of the container, MySQL runs all .sql or .sh scripts there to initialize the DB.\n\n- After initialization, new runs don\u2019t automatically re-run scripts unless you remove the container and volume.\n\n\u2757 This is not where live database data is stored. Live data is in /var/lib/mysql. Since you\u2019re not mounting that, the data lives in a Docker-managed anonymous volume.\n\nSo: Changing this bind mount will not remove your MySQL data. It only affects which init scripts would run on container creation.\n</code></pre>"},{"location":"Matlab_Data_Sources/#content-of-docker-composeyml-file-to-use-postgresql-database-as-docker-container-with-persistent-volume","title":"Content of docker-compose.yml file to use postgresql database as docker container (with persistent volume)","text":"<pre><code>services:\n  postgres:\n    image: postgres:16\n    container_name: ccp-multi-ied-multi-plc-pg\n    environment:\n      POSTGRES_USER: root\n      POSTGRES_PASSWORD: root\n      POSTGRES_DB: powerplant\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data   # &lt;-- persistent volume for DB data\n      - ./postgres-sql:/docker-entrypoint-initdb.d  # &lt;-- init scripts\n\nvolumes:\n  postgres_data:   # &lt;-- named volume definition\n</code></pre>"},{"location":"Matlab_Data_Sources/#steps-to-use-postgresql-database-with-matlab","title":"Steps to use PostgreSQL database with MATLAB:","text":"<ol> <li>Download JDBC driver from PostgreSQL JDBC site (check version of Java on MATLAB &amp; Postgres version)</li> <li></li> </ol>"},{"location":"PostgreSQL/","title":"PostgreSQL","text":""},{"location":"PostgreSQL/#using-postgresql-db-from-docker-composeyml","title":"Using Postgresql DB from docker-compose.yml","text":"<pre><code>services:\n  postgres:\n    image: postgres:16\n    container_name: ccp-multi-ied-multi-plc-pg\n    environment:\n      POSTGRES_USER: root\n      POSTGRES_PASSWORD: root\n      POSTGRES_DB: powerplant\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data # persistent volume for DB data\n      - ./postgres-sql:/docker-entrypoint-initdb.d # init scripts\n\nvolumes:\n  postgres_data: # named volume definition\n</code></pre> <p>Got it \u2705 \u2014 you\u2019ve already defined your PostgreSQL service with user root, password root, and database powerplant.</p> <p>Once you get a bash shell inside the container, you can access PostgreSQL using the psql client. Here\u2019s how:</p> <ol> <li>Get into the container\u2019s shell <code>docker exec -it ccp-multi-ied-multi-plc-pg bash</code></li> </ol> <p>To enter PostgreSQL:</p> <p><code>psql -U root -d powerplant</code></p> <p>will prompt for a password -&gt; type <code>root</code> based on docker-compose.yml used</p> <p>Once insde psql, you will see something like:</p> <p><code>powerplant=#</code></p> <p>Now you can run SQL commands:</p> <pre><code>\\l           -- list databases\n\\c powerplant -- connect to powerplant DB\n\\dt          -- list tables\nSELECT * FROM ref;\nSELECT * FROM ccp_values;\n</code></pre> <p>\ud83d\udca1 Optional tips and customizations 1\ufe0f\u20e3 Disable the pager temporarily</p> <p>If you just want to see everything inline for one session:</p> <p>\\pset pager off</p> <p></p> <ol> <li>run postgresql db as a docker container : inside ccp_multi_IED_multi_plc_database_pg folder : docker compose up -d</li> <li>go into postgresql db : docker exec -it ccp-multi-ied-multi-plc-pg bash psql -U root -d powerplant password: root to show tables : \\dt SELECT * FROM ccp_values;</li> <li>figure out how to connect to matlab using JDBC data source -&gt; configure JDBC data source ...connector for postgresql (driver) </li> </ol> <p>data source name : Postgres_CCP database name : powerplant server: localhost port number : 5432 </p> <p>currently on postgres: 16 and java 8+ </p> <p>\ud83d\udc49 So you should use the JDBC 4.2 driver (version 42.7.8, latest stable). That means: postgresql-42.7.8.jar is the right driver for you. check what the xsteam is for ... and whether it needs to be changed try running with the postgresql db -&gt; what is the next part that needs to be connected check whether IED scripts need to change part at establish_connection() ... conn = mysqlconnector.connect( ....</p> <p>XSteam.m , XSteamUS.m , license.txt , X Steam for Matlab.pdf </p> <p>previously for a JDBC data source on matlab that used mysql database , on the HOME tab, I had done these: I selected 'Set Path' , 'Add Folder' and then selected xsteam folder  which contained these 4 files , will it make sense to add this same path to the same folder after I changed database to postgresql but im using it for the same functionality ? what is the xsteam folder for and does any of the files in it need to be modified ?</p> <p>XSteam folder and files belong to an independent MATLAB library called XSteam, used to calculate thermodynamic properties of water and steam (e.g. enthalpy, entropy, temperature, pressure-volume relationships, steam quality etc. )</p> <ol> <li>in stored_procedure_pg_GT.sql -&gt; timestamp was changed to ts as timestamp is a reserved keyword in postgresql</li> </ol> <p>need to check if it affects anything in the IEDs or PLCs for GT</p> <p>check the changes needed for the IED files</p> <p>Since you\u2019ve switched from MySQL to PostgreSQL, you can\u2019t use mysql.connector anymore. You need to use a PostgreSQL driver, like psycopg2 or psycopg. Here\u2019s how you can modify your function:</p> <pre><code>import psycopg2  # PostgreSQL driver\n\ndef establish_connection():\n    conn = psycopg2.connect(\n        host=\"10.34.11.15\",        # your PostgreSQL host\n        port=5432,                  # default PostgreSQL port\n        user=\"root\",                # your PostgreSQL username\n        password=\"root\",            # your PostgreSQL password\n        database=\"powerplant\"       # your PostgreSQL database name\n    )\n    return conn\n</code></pre> <p>Key Changes:</p> <ol> <li>Driver: Use psycopg2 instead of mysql.connector.</li> <li>Port: PostgreSQL default is 5432 (MySQL default is 3306).</li> <li>SQL syntax: Some queries may need slight changes if they use MySQL-specific syntax (e.g., backticks <code>table</code> vs. double quotes \"table\" in PostgreSQL), but most simple SELECT statements are fine.</li> <li>Stored procedures/functions:</li> </ol> <p>In PostgreSQL, your stored procedures are functions, so you\u2019ll call them differently:</p> <pre><code>cur = conn.cursor()\ncur.execute(\"SELECT * FROM get_gt_ied_data();\")  # note the parentheses\nrows = cur.fetchall()\n</code></pre>"},{"location":"Recovering_VM/","title":"Recovering VM","text":""},{"location":"Recovering_VM/#at-grub-shell","title":"At GRUB Shell:","text":"<p>\ud83d\udd27 Steps to boot into text console At the grub&gt; prompt, run these exact commands:</p> <pre><code>set root=(hd0,gpt2)\n\nlinux /vmlinuz root=/dev/ubuntu-vg/ubuntu-lv ro systemd.unit=multi-user.target\n\ninitrd /initrd.img\n\nboot\n</code></pre> <p>\ud83d\udccc Explanation</p> <ul> <li> <p>set root=(hd0,gpt2) \u2192 tells GRUB where /boot is.</p> </li> <li> <p>linux /vmlinuz root=/dev/ubuntu-vg/ubuntu-lv ro systemd.unit=multi-user.target</p> </li> <li> <p>/vmlinuz \u2192 your kernel (symlink to latest: vmlinuz-6.8.0-71-generic).</p> </li> <li> <p>root=/dev/ubuntu-vg/ubuntu-lv \u2192 because your root filesystem is inside LVM (lvm/ubuntu--vg-ubuntu--lv showed up in your ls).</p> </li> <li> <p>systemd.unit=multi-user.target \u2192 boots into text console instead of GUI.</p> </li> <li>initrd /initrd.img \u2192 loads your initramfs.</li> <li>boot \u2192 starts the kernel.</li> </ul> <p>\ud83d\udda5\ufe0f After booting You\u2019ll land in a text login prompt. Login with your username/password. Then fix the problematic services:</p> <pre><code>sudo systemctl disable NetworkManager-wait-online.service\nsudo systemctl mask NetworkManager-wait-online.service\nsudo apt update\nsudo apt install --reinstall gdm3 virtualbox-guest-utils virtualbox-guest-x11 virtualbox-guest-dkms\nsudo systemctl set-default multi-user.target\n</code></pre> <p>Reboot:</p> <pre><code>sudo reboot\n</code></pre> <p>You should now get a stable text login every time. Once everything is fixed, you can switch back to GUI with:</p> <pre><code>sudo systemctl set-default graphical.target\nsudo systemctl isolate graphical.target\n</code></pre>"},{"location":"Recovering_VM/#checking-space-left-on-vm","title":"Checking space left on VM:","text":"<pre><code>\u2191 Share se into data and signature falled \nUbuntu 24.04.2 Clone [HSRG_PLC PPTwin] [Running] \nW: Failed to fetch http://ports.ubuntu.com/ubuntu-ports/dists/noble-updates/InRelease \nError writing to file - write (28: No space left on device) [IP: 185.12 190.36 80] \nW: Failed to fetch http://ports.ubuntu.com/ubuntu-ports/dists/noble-backports/InRelease Error writing to file write (28: No space left on device) [IP: 185. 5.190.36 80] \nW: Failed to fetch http://ports.ubuntu.com/ubuntu-ports/dists/noble-security/InRelease Error writing to file - write (28: No space left on device) [IP: 185.1 .190.36 80] \nW: Some index files failed to download. They have been ignored, or old ones used instead. \nsreedevi@sreedevi:~$ dpkg -1 'linux-image*' | grep ^ii ii \nlinux-image-6.8.0-71-generic ii  6.8.0-71.71 arm64 Signed kernel image generic\nlinux-image-generic 6.8.0-71.71 arm64 Generic Linux kernel image\nsreedevi@sreedevi :~$ sudo apt clean      \nsreedevi@sreedevi:~$ sudo journalctl -vacuum-time=2d \njournalctl: invalid option -- 'v' \nsreedevi@sreedevi :~$ sudo journalctl --vacuum-time=2d \nVacuuming done, freed B of archived journals from /var/log/journal/ef 121b3f41774ea893499e6942bb2ab8. \nVacuuming done, freed B of archived journals from /var/log/journal. \nVacuuming done, freed B of archived journals from /run/log/journal. \nsreedevi@sreedevi:~$ sudo rm -rf /var/lib/apt/lists/* \nsreedevi@sreedevi: \"$ df -h \nFilesystem Size Used Avail Use% Mounted on \ntmpfs 391M 1.3M 389M 1% /run \nefivarfs 256K 54K 203K 21% /sys/firmware/efi/efivars \n/dev/ubuntu-vg/ubuntu-lv 16G 15G \u00d8 100% / \ntmpfs 2.0G \u04e8 2.0G 0% /dev/shm\ntmpfs 5.0M 8.0K 5.0M 1% /run/lock \n/dev/sda2 2.0G 106M 1.7G 6% /boot \n/dev/sda1 1.1G 6.4M 1.1G 1% /boot/efi \nPOWER PLANT_TWIN 927G 421G 506G 46% /media/sf_POWER_PLANT_TWIN \nubuntu24_shared_folder 927G 421G 506G 46% /media/sf_ubuntu24_shared_folder \ntmpfs 391M 88K 390M 1% /run/user/1000 \nsreedevi@sreedevi:~$\n</code></pre> <ul> <li>Your root filesystem is: /dev/ubuntu-vg/ubuntu-lv   16G   15G   0   100%   / So your root volume is 16 GB and completely full. That\u2019s why apt fails and the VM hangs. Your /boot and /boot/efi partitions have space, but they don\u2019t help since all system packages/logs live under /.</li> </ul>"},{"location":"Recovering_VM/#free-some-emergency-space","title":"Free some emergency space","text":"<p>Just enough so apt and the system can breathe:</p> <pre><code>\n# Clear apt cache (already done, but run again just in case)\nsudo apt clean\n\n# Remove old logs\nsudo rm -rf /var/log/journal/*\n\n# Truncate big logs if they exist\nsudo truncate -s 0 /var/log/*.log\nsudo truncate -s 0 /var/log/*/*.log\n</code></pre>"},{"location":"Recovering_VM/#check-if-there-is-free-space-in-the-volume-group","title":"Check if there is free space in the volume group","text":"<pre><code>sreedevi@sreedevi:~$ sudo vgdisplay ubuntu-vg \n\nVolume group \n\nVG Name ubuntu-vg \nSystem ID \nFormat 1vm2 \nMetadata Areas 1 \nMetadata Sequence No 2 \nVG Access read/write \nVG Status resizable \nMAX LV \u04e8 \nCur LV 1 \nOpen LV 1 \nMax PV \u04e8 \nCur PV 1 \nAct PV 1 \nVG Size &lt;31.95 GiB \nPE Size 4.00 MiB \nTotal PE 8178 \nAlloc PE Size 4089 / 15.97 GiB \nFree PE Size 4089/15.97 GiB \nVG UUID TkZXdq-3dSV-izeB-Ewns-UJJn-1VaN-FLMNwc \nsreedevi@sreedevi:~$\n</code></pre> <p>This means the volume group <code>ubuntu-vg</code> is ~32 GB total, but only 16 GB is allocated to <code>/</code> (<code>/dev/ubuntu-vg/ubuntu-lv</code>). So this means you already have ~16GB free inside the VG ready to use - you don't even need to resize the VirtualBox disk.</p>"},{"location":"Recovering_VM/#expand-your-root-filesystem","title":"Expand your root filesystem","text":"<p>Run these 2 commmands:</p> <pre><code># Extend root LV to use all free space\nsudo lvextend -l +100%FREE /dev/ubuntu-vg/ubuntu-lv\n\n# Resize filesystem to fill LV\nsudo resize2fs /dev/ubuntu-vg/ubuntu-lv\n</code></pre> <pre><code>sreedevi@sreedevi:~$ sudo lvextend -1 +100%FREE /dev/ubuntu-vg/ubuntu-lv \n[sudo] password for sreedevi: \nSize of logical volume ubuntu-vg/ubuntu-lv changed from 15.97 GiB (4089 extents) to &lt;31.95 GiB (8178 extents). \nLogical volume ubuntu-vg/ubuntu-lv successfully resized. \nsreedevi@sreedevi :~$ sudo resize2fs /dev/ubuntu-vg/ubuntu-lv resize2fs 1.47.0 (5-Feb-2023) \nFilesystem at /dev/ubuntu-vg/ubuntu-ly is mounted on ; on-line resizing required old_desc_blocks = 2, new_desc_blocks = 4 \nThe filesystem on /dev/ubuntu-vg/ubuntu-lv is now 8374272 (4k) blocks long. \nsreedevi@sreedevi: df -h \nFilesystem Size Used Avail Use% Mounted on \ntmpfs 391M 1.3M 389M 1% /run \nefivarfs 256K 54K 203K 21% /sys/firmware/efi/efivars \n/dev/ubuntu-vg/ubuntu-lv 32G 15G 16G 50% / \ntmpfs 2.0G \u04e8 2.0G 0% /dev/shm \ntmpfs 5.0\u043c 8.\u043e\u043a 5.0\u043c 1% /run/lock \n/dev/sda2 2.0G 106M 1.7G 6% /boot \n/dev/sda1 1.1G 6.4M 1.1G 1% /boot/efi \nPOWER PLANT_TWIN 927G 422G 506G 46% /media/sf_POWER_PLANT_TWIN \nubuntu24_shared_folder 927G 422G 506G 46% /media/sf_ubuntu24_shared_folder \ntmpfs 391M 88K 390M 1% /run/user/1000 \nsreedevi@sreedevi:~$\n</code></pre> <p>issue faced when trying steps </p> <pre><code>sreedevi@sreedevi :~$ sudo apt install --reinstall gdm3 virtualbox-guest-utils virtualbox-guest-x11 virtualbox-guest-dkms. \nReading package lists... \nDone Building dependency tree... \nDone Reading state information... \nDone E: Unable to locate package virtualbox-guest-utils \nE: Unable to locate package virtualbox-guest-x11 \nE: Unable to locate package virtualbox-guest-dkms \nsreedevi@sreedevi: \"$ \n</code></pre> <p>Steps to fix boot delay from \"waiting for network online\" and reconfigure GDM for next boot: </p> <p>sudo systemctl disable NetworkManager-wait-online.service  sudo systemctl mask NetworkManager-wait-online.service  sudo apt update  sudo apt install spice-vdagent virtualbox-guest-additions-iso sudo systemctl set-default multi-user.target </p> <p>sudo systemctl set-default graphical.target # switching to GUI</p> <p>Prompt from me: After Select Advanced options for Ubuntu \u2192 recovery mode. Choose Root \u2013 Drop to root shell prompt. the prompt says enter for maintenance and press control D to continue after I pressed control d I see <code>root@sreedevi</code> how should I proceed to do these : sudo systemctl disable NetworkManager-wait-online.service sudo systemctl mask NetworkManager-wait-online.service sudo apt update sudo apt install virtualbox-guest-utils virtualbox-guest-x11 virtualbox-guest-dkms sudo dpkg-reconfigure gdm3</p> <p>If root filesystem is mounted as read-only : <code>mount -o remount,rw /</code></p> <p>After Select Advanced options for Ubuntu -&gt; recovery mode </p>"},{"location":"SQL/","title":"SQL","text":"<p>To check if a column exists in table ccp_values;</p> <p><code>SHOW COLUMNS FROM ccp_values</code></p> <p>After confirming a column exists, to see all values from the column eg. st_steam_mass_flow_rate from the table:</p> <p><code>SELECT st_steam_mass_flow_rate FROM ccp_values;</code> </p> <p>To see recent values eg. last 10 rows only:</p> <p><code>SELECT timestamp, st_steam_mass_flow_rate FROM ccp_values ORDER BY timestamp, DESC LIMIT 10;</code></p>"},{"location":"SSH/","title":"SSH","text":"<p>keypair was created using command like below on windows :</p> <p>ssh-keygen-t ed25519 ...</p> <p>had to convert the private key that was generated on windows using dos2unix as the line endings of the text file generated on windows will be based on carriage return  can check using cat -v ~/.ssh/id_ed25519_private If you see ^M at the end of lines \u2192 that\u2019s a Windows CR (\\r).</p> <p>command to ssh to ncl node 10.13 this does not work (as need to create a config file ): ssh -i ~/.ssh/id_ed25519_private -J ADSC_SmartGrid_5@gateway.ncl.sg -i ~/.ssh/id_ed25519_private pgt@10.10.10.13</p> <p>Create config file first</p> <pre><code># Gateway host\nHost gateway\n    HostName gateway.ncl.sg\n    User ADSC_SmartGrid_5\n    IdentityFile ~/.ssh/id_ed25519_private\n\n# Intermediate host\nHost intermediate\n    HostName 172.18.178.17\n    User pgt\n    Port 4696\n    IdentityFile ~/.ssh/id_ed25519_private\n    ProxyJump gateway\n\n# Final internal host\nHost pgt10.13\n    HostName 10.10.10.13\n    User pgt\n    IdentityFile ~/.ssh/id_ed25519_private\n    ProxyJump intermediate\n\n</code></pre> <p><code>chmod 600 ~/.ssh/config</code> <code>ssh -v pgt10.13</code></p>"},{"location":"ScadaLTS/","title":"ScadaLTS","text":""},{"location":"ScadaLTS/#content-of-docker-composeyml","title":"Content of docker-compose.yml","text":"<p>For Powerplant Twin</p> <pre><code>version: '3.8'\nservices:\n  database:\n    container_name: mysql\n    image: mysql/mysql-server:5.7\n    environment:\n      - MYSQL_ROOT_PASSWORD=root\n      - MYSQL_USER=root\n      - MYSQL_PASSWORD=root\n      - MYSQL_DATABASE=scadalts\n    ports:\n      - \"3307:3306\"\n    volumes:\n      - mysql-data:/var/lib/mysql\n    healthcheck:\n      test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\", \"-uroot\", \"-proot\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n      start_period: 20s\n\n  scadalts:\n    container_name: scadalts\n    image: scadalts/scadalts:latest\n    depends_on:\n      database:\n        condition: service_healthy\n    ports:\n      - \"8080:8080\"\n    expose:\n      - \"8000\"\n\nvolumes:\n  mysql-data:\n</code></pre>"},{"location":"VM-to-VM-Communication/","title":"VM-to-VM Communication","text":""},{"location":"VM-to-VM-Communication/#for-vm-to-vm-communication-on-virtualbox","title":"FOR VM TO VM COMMUNICATION ON VIRTUALBOX:","text":"<p>Had to use 2 adapters: NAT - enables internet connection for that VM Host only network - make sure to use the SAME host network for both </p>"},{"location":"Wine/","title":"Wine","text":"<p>How Linux WINE Works Under the Hood :</p> <p>https://www.youtube.com/watch?v=XSZ3UJbHqAk</p> <ul> <li>check about file sharing between wine -&gt; ubuntu -&gt; local pc (eg. MacBook)</li> <li>heck about file sharing between wine -&gt; local pc (eg. MacBook)</li> </ul> <p>https://unix.stackexchange.com/questions/344795/is-there-a-program-like-mobaxterm-for-linux-systems-sftp-gui-browser-termina</p>"},{"location":"Wine/#how-to-install-wine-on-ubuntu-2404-lts-linux-running-windows-programs-on-linux","title":"How to Install Wine on Ubuntu 24.04 LTS Linux | Running Windows Programs on Linux","text":"<p>https://youtu.be/J6EkEdQCNaQ?si=1QM9hzJSIiUMwCYW</p>"}]}