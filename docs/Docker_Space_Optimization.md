✅ Good — `docker system prune -a` ran successfully and reclaimed **2.26 GB**.

This is expected: most of the 62 GB in `/var/lib/docker` is still being used by:

* **Running containers** → `/var/lib/docker/overlay2` layers
* **Container logs** → `/var/lib/docker/containers`

The biggest remaining culprit is usually **logs from running containers**, which can grow very large, especially for long-running PLC/IED/SCADA containers.

---

# ✅ Step 2 — Clear container logs (safe, does NOT stop containers)

Check which logs are large:

```bash
sudo du -sh /var/lib/docker/containers/*/*-json.log | sort -h
```

Then truncate all logs:

```bash
sudo sh -c 'truncate -s 0 /var/lib/docker/containers/*/*-json.log'
```

✅ This frees space **immediately**
✅ Does not restart or break containers
✅ Very safe for persistent workloads

---

# ✅ Step 3 — Optional: prune unused Docker volumes

If you have volumes that are **truly unused**, you can run:

```bash
sudo docker volume prune
```

⚠️ Be careful — volumes may contain persistent databases or configs. Only delete if you are sure.

---

# ✅ Step 4 — Recheck disk usage

After truncating logs and pruning:

```bash
df -h
sudo du -h -d1 /var/lib/docker | sort -h
```

You should see **several tens of GB freed** and `/` no longer at 100%.

---

If you want, I can give you a **one-line set of commands** to safely reclaim the **maximum possible space** from your Docker setup **without deleting running containers or important volumes**.

Do you want me to do that?

# Question: How should I truncate logs based on the output below?

'''

ubuntu@pgt:~$ docker inspect --format='{{.HostConfig.LogConfig.Type}}' eg_plc                
json-file
ubuntu@pgt:~$ docker inspect --format='{{.HostConfig.LogConfig.Type}}' st_plc
json-file
ubuntu@pgt:~$ docker inspect --format='{{.HostConfig.LogConfig.Type}}' st_ied
json-file
ubuntu@pgt:~$ docker inspect --format='{{.HostConfig.LogConfig.Type}}' scadalts
json-file
ubuntu@pgt:~$ docker inspect --format='{{.HostConfig.LogConfig.Type}}' matlab_container
json-file
ubuntu@pgt:~$ docker inspect --format='{{.HostConfig.LogConfig.Type}}' mysql
json-file
ubuntu@pgt:~$ 
'''

Perfect — all your containers are using the **`json-file` logging driver**, which means:

✅ Logs are stored on the **host** at:

```
/var/lib/docker/containers/<container_id>/<container_id>-json.log
```

Truncating logs **inside the container won’t work**, you need to do it on the **host**.

---

# ✅ Step 1 — Truncate logs for all containers

Run this **one-liner on the host**:

```bash
sudo sh -c 'truncate -s 0 /var/lib/docker/containers/*/*-json.log'
```

Explanation:

* `truncate -s 0` → sets file size to 0 bytes
* `*/*-json.log` → matches all container log files
* Safe: does **not stop containers** or remove data

---

# ✅ Step 2 — Verify space reclaimed

```bash
df -h
sudo du -h -d1 /var/lib/docker/containers | sort -h
```

You should see `/var/lib/docker/containers` shrink significantly.

---

# ✅ Step 3 — Prevent logs from growing too large in the future

Edit or create Docker daemon config:

```bash
sudo nano /etc/docker/daemon.json
```

Add:

```json
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "50m",
    "max-file": "3"
  }
}
```

Then restart Docker:

```bash
sudo systemctl restart docker
```

✅ Limits each container log to **50 MB**, keeps **3 rotated files**, prevents `/var/lib/docker` from filling up again.

---

This will **safely free tens of GB** from your VM and prevent future log bloat.

If you want, I can give you a **single sequence of commands** to reclaim **all possible space in `/var/lib/docker`** without touching running containers or important volumes.


# Changes to Systemd - Will they persist when VM is extracted or only default settings persist? 

ubuntu@pgt:~$ systemd-delta
[OVERRIDDEN] /etc/tmpfiles.d/screen-cleanup.conf → /usr/lib/tmpfiles.d/screen-cleanup.conf

--- /usr/lib/tmpfiles.d/screen-cleanup.conf     2021-02-23 10:18:41.000000000 +0000
+++ /etc/tmpfiles.d/screen-cleanup.conf 2024-09-11 14:24:28.000000000 +0000
@@ -1 +1,2 @@
-d /run/screen 0777 root utmp
+# This file is generated by /var/lib/dpkg/info/screen.postinst upon package configuration
+d /run/screen 1777 root utmp

[OVERRIDDEN] /etc/systemd/system/sshd-keygen@.service.d/disable-sshd-keygen-if-cloud-init-active.conf → /usr/lib/systemd/system/sshd-keygen@.service.d/disable-sshd-keygen-if-cloud-init-active.conf

Files /usr/lib/systemd/system/sshd-keygen@.service.d/disable-sshd-keygen-if-cloud-init-active.conf and /etc/systemd/system/sshd-keygen@.service.d/disable-sshd-keygen-if-cloud-init-active.conf are identi>

[EQUIVALENT] /etc/systemd/system/multipath-tools.service → /usr/lib/systemd/system/multipath-tools.service
[MASKED]     /etc/systemd/system/systemd-networkd-wait-online.service → /usr/lib/systemd/system/systemd-networkd-wait-online.service
[EXTENDED]   /usr/lib/systemd/system/netfilter-persistent.service → /etc/systemd/system/netfilter-persistent.service.d/iptables.conf
[EXTENDED]   /usr/lib/systemd/system/rc-local.service → /usr/lib/systemd/system/rc-local.service.d/debian.conf
[EXTENDED]   /usr/lib/systemd/system/systemd-localed.service → /usr/lib/systemd/system/systemd-localed.service.d/locale-gen.conf
[EXTENDED]   /usr/lib/systemd/system/user@.service → /usr/lib/systemd/system/user@.service.d/timeout.conf

8 overridden configuration files found.
lines 1-21/21 (END)


# Question: Suggest a full checklist to verify that my extracted VM preserves all Docker, systemd, and network configurations before I start using it on the new host.

Absolutely — here’s a **comprehensive checklist** to verify your extracted Ubuntu VM so that Docker, systemd, and network configurations are preserved and the VM behaves as expected on the new host.

---

# **1️⃣ Verify VM Basics**

* ✅ Check disk space:

```bash
df -h
```

* ✅ Check hostname and networking:

```bash
hostname
ip a
ping 8.8.8.8
```

* ✅ Verify Ubuntu version:

```bash
lsb_release -a
uname -a
```

* ✅ Ensure root and user accounts exist and have correct permissions.

---

# **2️⃣ Verify systemd configuration**

* ✅ Run `systemd-delta` to confirm overridden, masked, and extended unit files:

```bash
systemd-delta
```

* Compare output to source VM — all `[OVERRIDDEN]` and `[EXTENDED]` entries should match.

* ✅ Check status of critical services (e.g., Docker, SSH, networking, custom PLC/IED services):

```bash
systemctl status docker
systemctl status <custom-service-name>
```

* ✅ List all enabled services:

```bash
systemctl list-unit-files | grep enabled
```

* ✅ Confirm masked services are still masked:

```bash
systemctl list-unit-files | grep masked
```

* ✅ Check drop-in files for custom units:

```bash
ls -l /etc/systemd/system/<unit>.service.d/
```

---

# **3️⃣ Verify Docker configuration and containers**

* ✅ Check Docker daemon info:

```bash
docker info
```

* Confirm `Docker Root Dir` is correct and matches your source VM.

* ✅ List all containers (running and stopped):

```bash
docker ps -a
```

* ✅ List images:

```bash
docker images
```

* ✅ Verify Docker volumes:

```bash
docker volume ls
docker volume inspect <volume_name>
```

* ✅ Check logging driver:

```bash
docker inspect --format='{{.HostConfig.LogConfig.Type}}' <container_name>
```

* ✅ Optional: Run a container and confirm it can access networks and volumes as expected.

---

# **4️⃣ Verify Docker networks**

* ✅ List networks:

```bash
docker network ls
```

* ✅ Inspect important networks (especially macvlan for PLC/IED):

```bash
docker network inspect <network_name>
```

* Check that IP ranges, subnets, and gateway settings match the source VM.

---

# **5️⃣ Verify network configuration outside Docker**

* ✅ List system network interfaces:

```bash
ip a
```

* ✅ Check routes:

```bash
ip route
```

* ✅ Check `netplan` or `networkd` configuration:

```bash
cat /etc/netplan/*.yaml
systemctl status systemd-networkd
```

* ✅ Verify firewall rules:

```bash
sudo iptables -L -n -v
sudo ufw status
```

---

# **6️⃣ Verify critical configuration files**

* ✅ Custom systemd service files:

```bash
ls -l /etc/systemd/system/
```

* ✅ Network-related files:

```bash
ls -l /etc/network/
ls -l /etc/systemd/network/
```

* ✅ Docker configuration:

```bash
cat /etc/docker/daemon.json
```

* ✅ Any custom scripts or applications used in PLC/IED services.

---

# **7️⃣ Test runtime functionality**

* ✅ Start Docker containers and ensure they start without errors:

```bash
docker-compose up -d  # if using docker-compose
docker start <container_name>
```

* ✅ Test service connectivity (PLC ↔ IED, MATLAB, SCADA, database):

```bash
docker exec -it <container> ping <other-container>
```

* ✅ Test any systemd services that should auto-start:

```bash
systemctl restart <custom-service>
systemctl status <custom-service>
```

* ✅ Optionally, run your usual workflow (PLC simulation, MATLAB scripts, SCADA dashboards) to ensure the VM works as intended.

---

# **8️⃣ Backup for safety**

* Before making major changes, consider taking a snapshot of the extracted VM in VirtualBox.
* This way you can revert if anything doesn’t behave as expected.

---

### ✅ **Summary**

Following this checklist ensures:

* All **systemd overrides, masks, and extensions** are preserved.
* Docker containers, images, volumes, and networks behave as expected.
* Network settings and connectivity match the source VM.
* Critical workflows and simulations will run after extraction.

---

If you want, I can **make a condensed “one-shot” set of commands** that you can run on the extracted VM to verify all of these points automatically and quickly.

Do you want me to do that?

